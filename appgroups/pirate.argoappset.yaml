apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: arr-apps
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "2"  # Deploy after core infrastructure
spec:
  goTemplate: true
  goTemplateOptions: ["missingkey=error"]
  generators:
  - matrix:
      generators:
      # First dimension: Applications
      - list:
          elements:
          - app: sonarr
            port: "8989"
            image: linuxserver/sonarr
          - app: radarr
            port: "7878"
            image: linuxserver/radarr
          - app: bazarr
            port: "6767"
            image: linuxserver/bazarr
          - app: lidarr
            port: "8686"
            image: linuxserver/lidarr
      
      # Second dimension: Clusters with media label
      - clusters:
          selector:
            matchLabels:
              argocd.argoproj.io/secret-type: cluster
              appgroup/pirate: "true"  # Only clusters with media storage
          values:
            # Extract cluster-specific values from annotations
            nfsServer: "danas.hangar.bpfx.org"
            nfsPath: "/volume1/dataz"
            domain: "abode.tailandtraillabs.org"
            storageClass: "local-path"
            timezone: "America/Chicago"

  template:
    metadata:
      name: '{{.name}}-{{.app}}'
      labels:
        app: '{{.app}}'
        cluster: '{{.name}}'
        app-group: media
      annotations:
        argocd.argoproj.io/compare-options: IgnoreExtraneous
        argocd.argoproj.io/sync-options: PruneLast=true
    spec:
      project: default
      
      source:
        repoURL: https://github.com/travismontana/ttl-ops # Update this
        targetRevision: main
        path: appgroups/pirate/arr-app
        helm:
          releaseName: '{{.app}}'
          values: |
            app:
              name: {{.app}}
            
            image:
              registry: lscr.io
              repository: {{.image}}
              tag: latest
              pullPolicy: IfNotPresent
            
            service:
              type: ClusterIP
              port: {{.port}}
            
            config:
              storageClass: "{{.values.storageClass}}"
              size: 1Gi
              accessMode: ReadWriteOnce
            
            media:
              nfs:
                server: "{{.values.nfsServer}}"
                path: "{{.values.nfsPath}}"
              mountPath: /media
            
            env:
              TZ: "{{.values.timezone}}"
              PUID: "1000"
              PGID: "1000"
            
            resources:
              requests:
                memory: "256Mi"
                cpu: "100m"
              limits:
                memory: "1Gi"
                cpu: "1000m"
            
            ingress:
              enabled: true
              className: traefik
              annotations:
                cert-manager.io/cluster-issuer: letsencrypt-prod
              hosts:
                - host: {{.app}}.{{.name}}.{{.values.domain}}
                  paths:
                    - path: /
                      pathType: Prefix
              tls:
                - secretName: wildcard-tls
                  hosts:
                    - {{.app}}.{{.name}}.{{.values.domain}}
      
      destination:
        server: '{{.server}}'
        namespace: media
      
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
          allowEmpty: false
        syncOptions:
          - CreateNamespace=true
          - PrunePropagationPolicy=foreground
          - PruneLast=true
        retry:
          limit: 5
          backoff:
            duration: 5s
            factor: 2
            maxDuration: 3m
      
      ignoreDifferences:
      - group: apps
        kind: Deployment
        jqPathExpressions:
        - .spec.template.metadata.annotations."kubectl.kubernetes.io/restartedAt"