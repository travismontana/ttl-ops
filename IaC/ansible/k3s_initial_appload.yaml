---
- name: Build dynamic inventory from clusters.json
  hosts: localhost
  connection: local
  gather_facts: no
  remote_user: root
  vars:
    clusters_file: "./clusters.json"
  
  tasks:
    - name: Read clusters.json
      slurp:
        src: "{{ clusters_file }}"
      register: clusters_raw

    - name: Parse clusters JSON
      set_fact:
        clusters_data: "{{ clusters_raw.content | b64decode | from_json }}"

    - name: Add hosts dynamically
      add_host:
        name: "{{ item.0.name }}-node{{ item.1 }}"
        ansible_user: ubuntu
        groups: 
          - k3s_cluster
          - "cluster_{{ item.0.name }}"
        ansible_host: "{{ item.0.name }}-node{{ item.1 }}.{{ clusters_data.domainname }}"
        cluster_name: "{{ item.0.name }}"
        domainname: "{{ clusters_data.domainname }}"
        node_index: "{{ item.1 }}"
        is_control_node: "{{ item.1 < item.0.numCnodes }}"
        is_first_control: "{{ item.1 == 0 }}"
        site: "{{ item.0.site }}"
        owner: "{{ item.0.owner }}"
        appgroups: "{{ item.0.appgroups }}"
        k3s_version: "v1.34.1+k3s1"
        k3s_token: "N2260mN2260m"
      loop: "{{ clusters_data.cluster | product(range(0, 10)) | list }}"
      when: item.1 < (item.0.numCnodes + item.0.numWnodes)

- name: Install Initial App Load on k3s Cluster
  hosts: k3s_cluster
  become: yes
  gather_facts: yes
  vars:
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
  module_defaults:
    group/kubernetes.core.k8s:
      kubeconfig: /etc/rancher/k3s/k3s.yaml
  tasks:
    - name: Install necessary packages
      when: is_first_control
      apt:
        name:
          - python3-pip
          - python3-venv
          - python3-kubernetes
        state: present
        update_cache: yes

    - name: Install Helm binary
      when: is_first_control
      block:
        - name: Download Helm
          ansible.builtin.get_url:
            url: https://get.helm.sh/helm-v3.16.2-linux-amd64.tar.gz
            dest: /tmp/helm.tar.gz

        - name: Extract Helm
          ansible.builtin.unarchive:
            src: /tmp/helm.tar.gz
            dest: /tmp
            remote_src: yes

        - name: Install Helm binary
          ansible.builtin.copy:
            src: /tmp/linux-amd64/helm
            dest: /usr/local/bin/helm
            mode: '0755'
            remote_src: yes

        - name: Clean up
          ansible.builtin.file:
            path: "{{ item }}"
            state: absent
          loop:
            - /tmp/helm.tar.gz
            - /tmp/linux-amd64

    - name: Ensure .kube directory exists
      when: is_first_control
      file:
        path: /home/ubuntu/.kube
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0700'
        
    - name: Copy kubeconfig to ubuntu home
      when: is_first_control
      copy:
        remote_src: yes
        src: /etc/rancher/k3s/k3s.yaml
        dest: /home/ubuntu/.kube/config
        owner: ubuntu
        group: ubuntu
        mode: '0600'
        
    - name: Create argocd namespace
      when: is_first_control
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: argocd

    - name: Ensure external-dns and cert-manager namespaces exist
      when: is_first_control
      shell: |
        kubectl create namespace external-dns --dry-run=client -o yaml | kubectl apply -f -
        kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -
      environment:
        KUBECONFIG: /etc/rancher/k3s/k3s.yaml

    - name: Create route53-credentials secret
      when: is_first_control
      shell: |
        kubectl create secret generic route53-credentials \
          -n external-dns \
          --from-literal=aws-access-key-id="{{ aws_access_key }}" \
          --from-literal=aws-secret-access-key="{{ aws_secret_key }}" \
          --dry-run=client -o yaml | kubectl apply -f -
        kubectl annotate secret route53-credentials \
          -n external-dns \
          reflector.v1.k8s.emberstack.com/reflection-allowed="true" \
          reflector.v1.k8s.emberstack.com/reflection-allowed-namespaces="cert-manager" \
          --overwrite
        kubectl create secret generic route53-credentials \
          -n cert-manager \
          --from-literal=aws-access-key-id="{{ aws_access_key }}" \
          --from-literal=aws-secret-access-key="{{ aws_secret_key }}" \
          --dry-run=client -o yaml | kubectl apply -f -
      environment:
        KUBECONFIG: /etc/rancher/k3s/k3s.yaml

    - name: Install ArgoCD via Helm
      when: is_first_control
      block:
        - name: Add ArgoCD Helm repository
          kubernetes.core.helm_repository:
            name: argo
            repo_url: https://argoproj.github.io/argo-helm

        - name: Create ArgoCD bootstrap values
          copy:
            content: |
              # Minimal bootstrap config - full config managed by argo-bin app
              server:
                extraArgs:
                  - --insecure
                service:
                  type: ClusterIP
              
              configs:
                params:
                  server.insecure: "true"
              global:
                domain: "{{ cluster_name }}.{{ domainname }}"
                labels:
                  ttl-ops/marco: polo

              server:
                extraArgs:
                  - --basehref=/argocd
                  - --rootpath=/argocd
                  - --insecure

                ingress:
                  enabled: true
                  ingressClassName: traefik
                  hostname: "{{ cluster_name }}.{{ domainname}}"
                  path: /argocd
                  pathType: Prefix
                  annotations:
                    cert-manager.io/cluster-issuer: letsencrypt-prod
                  tls:
                    - secretName: "wildcard-tls"
                      hosts:
                        - "{{ cluster_name }}.{{ domainname }}"

              configs:
                params:
                  server.basehref: /argocd
                  server.rootpath: /argocd
                  server.insecure: "true"
              
            dest: /tmp/argocd-bootstrap-values.yaml

        - name: Deploy ArgoCD
          kubernetes.core.helm:
            name: argocd
            chart_ref: argo/argo-cd
            chart_version: "9.1.3"  # Or whatever version you want
            release_namespace: argocd
            create_namespace: true
            values_files:
              - /tmp/argocd-bootstrap-values.yaml
            kubeconfig: /etc/rancher/k3s/k3s.yaml 
            wait: true

        - name: Wait for ArgoCD to be ready
          kubernetes.core.k8s_info:
            kind: Deployment
            namespace: argocd
            name: argocd-server
            wait: yes
            wait_condition:
              type: Available
              status: "True"
            wait_timeout: 300

      always:
        - name: Clean up bootstrap values
          file:
            path: /tmp/argocd-bootstrap-values.yaml
            state: absent

    - name: Wait for ArgoCD to fully initialize
      when: is_first_control
      shell: |
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-application-controller -n argocd --timeout=300s
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-applicationset-controller -n argocd --timeout=300s
        sleep 15
      environment:
        KUBECONFIG: /etc/rancher/k3s/k3s.yaml

    - name: Create cluster-in-cluster secret
      when: is_first_control
      shell: |
        kubectl create secret generic cluster-in-cluster \
          -n argocd \
          --from-literal=name={{cluster_name}} \
          --from-literal=server=https://kubernetes.default.svc \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Label cluster-in-cluster secret
      when: is_first_control
      shell: |
        kubectl label secret cluster-in-cluster \
          -n argocd \
          argocd.argoproj.io/secret-type=cluster \
          clustername="{{ cluster_name }}" \
          domainname="{{ domainname }}" \
          --overwrite
    - name: Label cluster-in-cluster secret with appgroups
      when: is_first_control
      shell: |
        kubectl label secret cluster-in-cluster \
          -n argocd \
          {{ item }}=true \
          --overwrite
      loop: "{{ appgroups.keys() | list }}"
      environment:
        KUBECONFIG: /etc/rancher/k3s/k3s.yaml

#    - name: Create ArgoCD bootstrap Application
#      when: is_first_control
#      kubernetes.core.k8s:
#        state: present
#        definition:
#          apiVersion: argoproj.io/v1alpha1
#          kind: Application
#          metadata:
#            name: argocd
#            namespace: argocd
#          spec:
#            project: default
#            source:
#              repoURL: https://github.com/travismontana/ttl-ops
#              path: appgroups/argocd
#              targetRevision: HEAD
#              helm:
#                parameters:
#                  - name: clusterName
#                    value: "{{ cluster_name }}"
#            destination:
#              server: https://kubernetes.default.svc
#              namespace: argocd
#            syncPolicy:
#              automated:
#                prune: true
#                selfHeal: true

    - name: Install the core ApplicationSet
      when: is_first_control
      shell: |
        kubectl apply -f https://raw.githubusercontent.com/travismontana/ttl-ops/refs/heads/main/appgroups/core.argoappset.yaml